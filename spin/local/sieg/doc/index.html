<HTML>
<head>
<TITLE> SIEG </TITLE>
</head>

<BODY>
Last Updated : Thu Nov 21 20:11:03 1996
<h1> 
<A href="http://www.cs.washington.edu/general/sptm-caption.html">
<IMG src="http://www.cs.washington.edu/general/sptm_s.gif"></a>
<!-- SPIN DOC EXPORT SECTION IGNORE END -->
SIEG : SPIN Interface to Extension Generator
</h1>

<h2>Contents</h2>

<!--menu>

<hr>

<h2> Overview </h2>

<b>Sieg</b>(SPIN Interface to Extension Generator) is a stub generator
for user/extension data exchanges.

It reads a systemcall definition file, which is actually a Modula 3
interface file furnished with various <a href="#pragmas">pragmas</a>.
Then it outputs files used by user space programs and
extensions.<p>

There are two benefits in using Sieg.

<ul>
  <li> It automates the creation of tedious system call dispatching and
       argument unmarshalling codes you typically need when you want to write
       a system-call.
  <li> It allows to describe system calls in architecture independent way.
</ul>

See <a href="userappdemo.html">Hello extension demo</a> for a simple
example using Sieg.

<h2>Files Generated by Sieg</h2>

Sieg reads a systemcall definition file(say, Foo.i3), and produces
five files.  Foo.i3 itself is also used as the interface definition
for the extension code.

<dl>
  <dt> <b>FooUser.i3</b>
  <dd> User side interface file. This file is used by user-space Modula-3
       applications. If you just want to run C applications on user space,
       you don't need to use this file.
       
       It's contents are almost equal to
       the original Foo.i3, but are different in some parts.

       <ul>
	 <li> all procedures are marked &lt*EXTERNAL ..*&gt, since they
	      are implemented in assembly file FooUser.s
	 <li> all opaque references that are used as
	      return values from the procedures, or as VAR parameters
	      are changed to INTEGER.
	 <li> changes in cosmetic level. For example, all
	      constant expressions are folded, comments are stripped off, etc.
       </ul>       

  <dt> <b>FooUser.s</b>
  <dd> Implements the procedures defined in FooUser.i3. An Alpha, they
       just load the procedure ID into the <code>v0</code> register,
       and traps into the kernel.

  <dt> <b>foo_user.h</b>
  <dd> C header file. This file is created only when the <code>-gch</code>
       flag is passed to Sieg.
       This may be used by user-space applications written in C.
       The name of this file is produced by
       changing all the letters lowercase and appending "_user.h" at the end.
       For example, if you process FooBarBaz.i3, then the file
       foobarbaz_user.h is created.

       <blockquote>The reason the filename is <code>foo_user.h</code> and not
       <code>FooUser.h</code> is that the m3 compiler generates
       the file with same name.
       </blockquote>

  <dt> <b>FooExtension.i3</b>
  <dd> Declares the procedure <code>Syscall</code>,
       which is the event handler called in response to user system calls.

  <dt> <b>FooExtension.m3</b>
  <dd> Implements the procedure
       <code>Syscall</code>. This is used as a handler for the
       <code>MachineTrap.Syscall</code> event.
       It also contains argument marshalling procedures for each system call.
       
       Note that FooExtension.m3 itself <strong>does not</strong>
       install <code>Syscall</code> to the <code>MachineTrap.Syscall</code>
       event. You either have to install it manually, or use
       USyscall rendezvous mechanism.

       To install it manually, you have to execute the below code somewhere.

      <pre>
Dispatcher.InstallHandler(MachineTrap.Syscall, NIL, FooExtension.Syscall);
       </pre>
       
</dl>  

Suppose Foo.i3 looks like following.

<pre>
INTERFACE Foo;
PROCEDURE Bar(x : INTEGER; VAR y : INTEGER) : BOOLEAN;
END Foo.
</pre>

To call the system call <code>Bar</code> from the user space m3
applications, call the procedure <code>FooUser.Bar</code>.
<code>FooUser.Bar</code> calls an assembly procedure
<code>Foo_Bar</code>, and it traps into the kernel.  From a C program,
just call <code>FooUser_Bar</code>.

<p> In kernel, the spincore raises the
<code>MachineTrap.Syscall</code> event in response to the system call. 
The dispatcher routes the event to <code>FooExtension.Syscall</code>.
This procedure looks at the procedure ID, unmarshalls the argument
from either register or memory, and calls <code>Foo.Bar</code>.

<h2> Directory Structure </h2>

A typical directory structure for programs using sieg is shown below.

<ul>
  <li> <code>user/foo/src/Foo.i3</code><br>
This file defines the interface between the user and the extension.
  <li> <code>user/foo/src/Foo.m3</code><br>
This file implements the extension. 
  <li> <code>user/foo/ALPHA_SPIN/</code><br>
This directory contains the all the sieg-generated files described
       in the previous section.
</ul>

<a name="calling"></a>
<h2> Calling Sieg </h2>

<h3> Calling from m3makefile</h3>

The norm of using sieg is from
<!href="m3makefile.html">m3makefile</a>.
First, the domain "Sieg" has to be imported. This domain contains
some helper functions used by sieg-generated codes.

<pre>
DomainImport("Sieg", "user", "sieg", overridepath)
</pre>

This declaration automatically reads in a quake template file for Sieg
called <code>sieg.tmpl</code> located under
<code>user/sieg/src</code>.  Then, write

<pre>
Sieg_interface("Foo")
</pre>

or

<pre>
sieg_interface("Foo")
</pre>

The former statement generates all the stub files, and make
<code>Foo.i3</code> public. The latter statement is similar except
that <code>Foo.i3</code> is made private to this domain.

<p>
There are some restrictions on where <code>Sieg_interface</code> or
<code>sieg_interface</code> can be placed in <code>m3makefile</code>.

<ul>
  <li> They have to appear after <code>Package</code> declaration.
  <li> They have to appear after <code>interface</code> or <code>module</code>
       declarations of all the local modules that <code>Foo</code> imports.
</ul>

The upshot is that it is always safe to put <code>Sieg_interface</code>
or <code>sieg_interface</code> at the bottom of the m3makefile.

<h3>Starting Sieg Directly</h3>

You can also call sieg directly from the command line.
It's useful only when debugging sieg itself.

<pre>
% sieg Foo.i3 [-st PATH-W/O-SUFFIX] [-gch] [-v] [-T.M3IMPTAB]
</pre>

<dl>
  <dt> <strong><code>-gch</code></strong>
  <dd> it stands for GenerateCHeader. If this option is set, sieg
generates foo_user.h.
  <dt> <strong><code>-v</code></strong>
  <dd> output verbose messages.
  <dt> <strong><code>-T<var>TABLEFILE</var></code></strong>
  <dd> This option specifies the location of the m3 import table file.
       This option is necessary when Foo.i3 import any module.
       Don't try to create the import table by your own. The best way
       is to copy the file <code>ALPHA_SPIN/.M3IMPTAB</code> from
       where you previously ran sieg, and use it.
</dl>

<a name="idl"></a>
<h2>Writing Systemcall Definition File</h2>

Basically, systemcall definition file is a Modula-3 interface file.
You can define types, constants, and procedures here.  Besides being
used as the interface definition to Sieg, this file is also used as
the interface definition for extensions.<p>

Special directives to Sieg are given through pragmas.  The pragmas are
described in the next <a href="#pragmas">section</a>.<p>

However, there are some caveats.  Some of them are restrictions
inherent to any stub generator, and some of them are just a
restriction in the current implementation.  Restrictions coming from
the implementation is marked "(s)".

<ul>
  <li> (s) On Alpha, procedures with more than 6 arguments are not
       allowed, since Sieg does not support argument passing
       through stack now.

       <p> On x86, there is no such restriction because all parameters are
       passed by stack anyway.
       
  <li> (s) Each argument has to fit in a register, i.e., you can't pass
       aggregate values. Each argument has to be either VAR, READONLY or REF.
       
  <li> Variable declarations are not allowed. Naturally, you
       can't communicate using variables between user and kernel space.
  <li> Partially or completely revealed objects are not allowed.
       It's ok to use <code>ROOT</code>, but you can't use
       revealed objects.<br>

       <blockquote>
       <strong>Note: </strong>
       This restriction is partly due to the implementation; 
       it is possible to support opaque objects from which no
       member variable is revealed. Reason such objects are not
       supported is just because they are complicated.
       If an opaque object contains member variable, it is impossible
       to pass it between user and kernel. The reason is same as
       the reason shared variables aren't allowed.
       </blockquote>
       
  <li> (s) Multi-dimensional arrays aren't supported.
  <li> (s) TEXT values are always read only.
       If you modify a text parameter using <code>Text.SetChars</code>,
       the result is not passed.
       
  <li> (s) Returning a value that doesn't fit in a register
       (eg, returning a record).

  <li> Procedure as a type.<br>
</ul>
  
<a name="pragmas"></a>
<h2>Pragmas </h2>

Sieg supports several pragmas.

<ul>
  <li> <b><code>AS CTEXT</code></b>
       <pre>
       PROCEDURE Hello(<*AS CTEXT*> s : TEXT);
       PROCEDURE Hello2(<*AS CTEXT*> VAR s : ARRAY OF CHAR);
       PROCEDURE Hello3(<*AS CTEXT*> READONLY s : ARRAY OF CHAR);
       </pre>

       The type of the variable following this pragma has to be
       either <code>TEXT</code> or <code>VAR ARRAY OF CHAR</code> or
       <code>READONLY ARRAY OF CHAR</code>.
       This pragma makes the parameter a "C-style text". C-style text is a
       C style null-terminated string on the user side, and it is
       converted into Modula-3 style TEXT or ARRAY OF CHAR
       by the extension stub code.

       In the example above, the procedures have signatures like below
       on the user side.
       
       <pre>
       void Hello(char *s);
       void Hello2(char *s);
       void Hello3(char *s);
       </pre>

       On the extension side, their signatures becomes below.

       <pre>
       void Hello(s : TEXT);
       void Hello2(VAR s : ARRAY OF CHAR);
       void Hello3(READONLY s : ARRAY OF CHAR);
       </pre>

       If you call <code>Hello("hi, dad");</code> from the user space,
       you just pass the pointer to the string.
       On the kernel side, the stub code
       reads the stuff pointed to by <code>s</code>, and treats
       it as null terminated string, and creates appropriate TEXT
       (or VAR ARRAY OF CHAR or READONLY ARRAY OF CHAR) object that contains
       <code>"hi, dad"</code>.<p>

       When the parameter type is VAR(or READONLY) ARRAY OF CHAR, the
       stub procedure allocates a 1024 byte buffer on the stack, and
       reads in the string there. Therefore, CTEXT VAR ARRAY OF CHAR incurs
       no heap allocation. <br>

       <strong>XXX we have to provide means to change the buffer size!</strong><br>

       
       
       <p><code>&lt*CTEXT*&gt</code> can also be attached to record fields.
       In this case, the variable name has to be TEXT,
       not VAR ARRAY OF CHAR or READONLY ARRAY OF CHAR (this comes from
language restriction that there is no open array variable).

       <pre>
       TYPE Foo = RECORD
           x : CARDINAL;
           <*CTEXT*>y : TEXT;
       END;
       </pre>

  <li> <b><code>AS EXTENSIONONLY</code></b><br>

       This pragma can be attached to parameters(or record fields)
       of the following types.

       <ul>
	 <li> <!href="strands">Strand.T</a>
	 <li> VAR <!href="MachineCPU.i3">MachineCPU.SavedState</a>
	 <li> <!href="memory">Space.T</a>
       </ul>

       When a type is marked <code>EXTENSIONONLY</code>, then the
       value is not passed by the client, but is produced by
       the extension side stub.<p>

       When the parameter type is Strand.T, then the current
       <!href="user space thread">user space thread</a> is passed as the
       value. When the type is MachineCPU.SavedState, the state of the
       user space thread just after the systemcall entry is passed.
       When the type is Space.T, then the space on which the current
       user space thread is running is passed as the value.<p>
       
       Let's see an example.
       
       <pre>
PROCEDURE DoStuff(<*AS EXTENSIONONLY*>thread : Strand.T;
                  <*AS EXTENSIONONLY*>VAR state : MachineCPU.SavedState);
       </pre>

       This <code>DoStuff</code> system call does not take parameter
       from the user code. Thus, the user side signature will be
       
       <pre>
void DoStuff();
       </pre>

       The values of the parameters <code>thread</code> and <code>state</code>
       are supplied by the stub procedure. <p>

       <blockquote><strong>Note:</strong>
       There are library procedures <code>UserSpaceThread.Self()</code>
       and <code>Sieg.GetSpace()</code> that can be used in place of
       extensiononly Thread.T and Space.T. 
       You should avoid using this pragma and use the libraries
       if possible, since this makes the code difficult to read.<p>

       However, there are a few cases where you need this pragma.<p>

       One case is when you need MachineCPU.SavedState. Currently,
       there is no way to get the user space register frame 
       other than <code><*AS EXTENSIONONLY></code>.<p>

       The other case is when you want to make a system call really
       <em>fast</em>. When a procedure signature is like below,

       <pre>
       PROCEDURE Foo (<*AS EXTENSIONONLY*>t : Strand.T;
                      <*AS EXTENSIONONLY*>VAR s : MachineCPU.SavedState);
       </pre>

       sieg understands this particular parameter combination, and 
       it won't generate stub code. It calls the extension side
       procedure directly.
      </blockquote>

  <li> <b><code>AS</code> <var>m3-format</var>[!<var>c-format</var>]</b>
       <pre>
       TYPE Foo = REF RECORD ... END;
       PROCEDURE Hello(<*AS VAR %s : Foo*> s : INTEGER);
       PROCEDURE Hello2(<*AS VAR %s : INTEGER!char *%s*> s : INTEGER);
       </pre>

       This pragma is used when you want to use different types
       for a parameter between user and kernel.
       The kernel side type must always be <code>INTEGER</code> or
       <code>Word.T</code>.
       
       <var>m3-format</var> is used the parameter type on the user side
       m3 stub, and an optional <var>c-format</var>
       is used as the parameter type on
       the user side C stub.

       In the example above, the parameter <code>s</code>
       of both <code>Hello</code> and <code>Hello2</code> are
       <code>INTEGER</code>.

       This is useful when you want to pass a pointer
       to a variable sized buffer. For example, in
       <!href="dlib">Dlib</a>, <code>Read</code> is defined like following
       (<code>Read</code> implements UNIX <code>read(2)</code>).

       <pre>       
<*SYNONYMS read,__read*>  
PROCEDURE Read(fh : FH;
	       <*AS VAR %s : INTEGER!char *%s*>t : INTEGER;
	       size : INTEGER)
  : INTEGER RAISES {Error.E, Space.BadSize, Space.Failure};
       </pre>

       The user side procedure for this systemcall looks like
       following:

       <pre>
long Dlib_Read(long fh, char *t, long size);
       </pre>

       The virtual address <code>t</code> of the buffer is passed
       to the extension procedure directly. In the extension proc,
       you have to manually write into the user space like below.

       <pre>       
PROCEDURE Read (fh : FH; addr : INTEGER; size : INTEGER)
  	: INTEGER RAISES {Error.E, Space.BadSize, Space.Failure} =
  VAR buf : REF ARRAY OF CHAR;
    nRead : CARDINAL;
    space := Sieg.GetSpace();
  BEGIN
    nRead := size;
    (* Read from the file into "buf" *)       
    fh.h.read(fh.offset, nRead, buf);
    (* Write the content of "buf" into the user space. *)
    Space.Write(space, buf^, addr, nRead);
    INC(fh.offset, nRead);
    RETURN nRead;
  END Read;
        </pre>
       

  <li> <strong><code>DESCENDING_PROC_IDS</code></strong><p>

       This pragma tells sieg that the procedure IDs should be assigned
       in descending order. For example,

       <pre>
       <*INTERFACE_PROC_BASE -1*>
       <*DESCENDING_PROC_IDS*>
       PROCEDURE P1();
       PROCEDURE P2();
       </pre>

       The procedure <code>P1</code> has the ID -1, and <code>P2</code>
       has the ID -2.

  <li> <strong><code>EPILOG_BRANCH_ON_REGISTER</code></strong>

       <pre>
       <*EPILOG_BRANCH_ON_REGISTER _Seterrno*>
       </pre>

       If this pragma is found anywhere in the interface definition,
       sieg outputs a user side code that, after each system call,
       checks the value of <code>a3</code> register and if it isn't 0,
       calls the function specified in the pragma(in the above example,
       <code>_Seterrno</code>), passing the value of <code>a3</code>.<p>

       Thus on Alpha, the assembly stub looks like:

       <pre>
       lda v0,  <var>PROCEDURE-ID</var>(zero)
       call_pal PAL_callsys
       bne      a3, syscall_error
       jmp	zero, (ra)
syscall_error:
       bis 	a3, a3, a0
       lda 	t12, _Seterrno
       jmp 	zero, (t12)
       </pre>

       On the extension side, sieg outputs the stub that catches
       certain kind of exceptions, and converts the exception into
       an error code and assigns that to <code>a3</code>. 
       The exceptions currently supported are Error.E, Space.BadSize,
       Space.Failure, and SpinException.Exception. The conversion from
       these exceptions into <code>a3</code> value is hardcoded currently.
       If you raise other exceptions, your extension will crash in
       firewall. <p>

       <blockquote><strong>Note :</strong> the register a3 is chosen because
       OSF/1 uses it to
       hold errno. </blockquote>

  <li> <b><code>INTERFACE_PROC_BASE</code></b>
       
       <pre>
       <*INTERFACE_PROC_BASE xxx*>
       </pre>       

       By placing this pragma(xxx is some integer), you can change this value.
       
       <pre>
       <*INTERFACE_PROC_BASE 234*>
       PROCEDURE Hello(x : CARDINAL);
       </pre>

       If you don't specify anything, the the proc base will be the
       hash code of the interface name you are compiling
       (i.e., the value of <code>Text.Hash("Foo")</code>).
       
  <li> <b><code>NO_SMALL_VAR_OPTIMIZATION</code></b>

       By default, for <code>VAR</code> parameter whose size is
       not larger than the CPU word size, sieg passes the value
       by call-by-value-result (ie, the protocol used in older
       Fortran compilers where the param is passed by value on entry, and
       the value is somehow passed back on return, and that value is
       written back to the caller-side param var).

       <p> This pragma disables this optimization. Used to emulate some
       existing systemcall interface.
       
  <li> <b><code>OUT</code></b>

       <pre>
       PROCEDURE Hello(<*OUT*>VAR x : INTEGER);
       </pre>

       <code>&lt*OUT*&gt</code> can be placed just before <code>VAR</code>
       keyword. This makes the parameter write only. The stub code does not
       extract the value from the user space upon call, but the value
       is written back to the user space upon return.

  <li> <b><code>PROCID</code></b>

       <pre>
       <*PROCID 4035*>
       PROCEDURE Whatever(x : Any);
       </pre>

       This pragma changes the ID of the following procedure.
       In the above example, the ID of <code>Whatever</code> procedure
       becomes 4035. The subsequent procedures will have IDs
       4036, 4037, ... if <code>DESCENDING_PROC_IDS</code> in not set,
       4034, 4033, ... otherwise.

       <p>
       <code>PROCID</code> is now the
       preferred way to override the procedure ID
       over <code>SKIP</code> pragma described next.
       
  <li> <b><code>SKIP</code></b>

       <pre>
       <*SKIP 4032 .. 4045*>
       PROCEDURE Whatever(x : Any);
       </pre>

       The <code>SKIP</code> pragma can be placed just before
       a procedure declaration. This pragma tells sieg to
       skip the procedure IDs. It has the form

       <center><code>
       <*SKIP <var>FROM</var>..<var>TO</var>*>
       PROCEDURE Foo(...)
       </code></center>

       <var>FROM</var> must be one greater than the ID of the procedure
       just preceding <code>Foo</code>(when <code>DESCENDING_PROC_IDS</code>
       is specified, the ID must be one smaller than the previous one).
       
       The procedure ID of <code>Foo</code> will be <var>TO+1</var>.
       (when <code>DESCENDING_PROC_IDS</code> is set, the ID will be
       <var>TO-1</var>).
       
  <li> <strong><code>SYNONYMS</code></strong>

       <pre>
       <*SYNONYMS getpid,__getpid*>
       PROCEDURE GetPID() : INTEGER; 
       </pre>

       You can change the user side stub name using this
       pragma. In the above example, <code>GetPID</code> is the extension
       side name for the procedure, but on the user side, the names
       <code>Dlib_GetPID</code>, <code>getpid</code>,
       and <code>__getpid</code> are used for the assembly stub routine.
</ul>

<A name="exceptions"></a>
<h2> Exceptions </h2>

System calls may raise exceptions. Sieg converts exceptions to system
call errors. System call errors are a way to transfer an error
condition back to user space. On Alpha, <code>a3</code> register is
used to notify an error to user space applications.  Sieg currently
have hard-coded knowledge of converting exceptions to appropriate
<code>a3</code> value. Below are the set of exceptions understood by
Sieg.

<pre>
Error.E VMError.E NameServer.Error Errno.UnixError
</pre>

Sieg reports an error if system calls raise exceptions not understood
by it.

<A name="externalized"></a>
<h2> Externalized References </h2>
<ul>
  <li> If an instance of a REF type is
       used as a return value of some procedure, or is used as
       a VAR parameter to some procedure, then that type is 
       treated as Word.T on the user side, and the value is
       <a href="../../../kernel/spincore/src/utils/doc/externref.html">
       internalized</a> upon call, and
       <a href="../../../kernel/spincore/src/utils/doc/externref.html">
       externalized</a> upon return. This happens automatically.<br>


       <pre>
       TYPE T \&lt: REFANY;
       PROCEDURE Foo(x : INTEGER) : T;
       </pre>

       In the above case, T becomes a alias to Word.T in the user side
       i3. Thus, the user side procedure for Foo will look like

       <pre>
       long Foo(long x);
       </pre>

       <blockquote>
       <code>Note:</code>There is no explicit way to specify that some
       type must be externalized
       /internalized upon call/return.
       </blockquote>

</ul>

<a name="runtime"></a>
<h2>Runtime Support</h2>

Codes generated by Sieg uses a runtime support package called
<a href="../../../user/sieg/src/Sieg.i3">Sieg</a>.
It's usually used implicitly by stub codes generated by Sieg, but
you can also call it directly.

<a name="tricks"></a>
<h2> Programming Tips </h2>

  <ul>
    <li> Getting the thread identity. <br>
  
	 Some times, you want to know who you are, or who the
	 user-level client is. There are several helper procs for this purpose.

	 <pre>
	 UserSpaceThread.Self() : UserSpaceThread.T;
	 Sieg.GetSpace() : Space.T;
	 </pre>

	 You can also use <*AS EXTENSIONONLY*> pragma, but this is the
	 preferred method(because it's less hairy). 
  </ul>

<A name="example"></a>
<h2> Example </h2>

  We have two examples. <a href="userappdemo.html">Hello</a> is a
  very simple syscall extension designed solely for demonstration.<p>

  Sphinx is a no-nonsense UNIX emulation library. 

<ul>
  <li> <!href="Sphinx.i3">Sphinx.i3</a><br>
This is the original source file. If your process this file using sieg,
the below 5 files are generated.
  <li> <!href="SphinxUser.i3">SphinxUser.i3</a>
  <li> <!href="SphinxUser.s">SphinxUser.s</a>
  <li> <!href="Sphinx_user.h">Sphinx_user.h</a>
  <li> <!href="SphinxExtension.i3">SphinxExtension.i3</a>
  <li> <!href="SphinxExtension.m3">SphinxExtension.m3</a>
  <li> <a href="../../../user/sphinx/progs/hello.c">hello.c</a><br>
A user side sample program written in C.
  <li> <!href="Sphinx.m3">Sphinx.m3</a><br>
An extension side sample program.
  <li> <!href="Sphinxcore/src/m3makefile">Extension side m3makefile</a>
  <li> <!href="Sieg.i3">Sieg.i3</a>, the runtime support.
  <li> <!href="Sieg.m3">Sieg.m3</a>, the runtime support.
</ul>

<A name="running"></a>
<h2>Running the Example</h2>
To execute this program, you first do <code>script -b</code>
the kernel.

<pre>
!\&gt;script -b
</pre>

Then, run the user program.

<pre>
!\&gt;exec /spin/yasushi/spin/user/sphinx/progs/hello
</pre>

<A name="future"></a>
<h2>Future Enhancements</h2>

<ul>
  <li> Returning dynamic values from extension.<br>


       For example, we can't return TEXT from extension to user now.
       I'm considering an implementation like below.

       <ol>
	 <li> Suppose an extension wants to return a text "FOO".
	      It first externalizes "FOO" and returns the capability
	      to the user.
	 <li> The user code receives the capability C, and calls an
	      extension "getTextLength(C)". This extension interalizes
	      the argument, and narrows the reference into TEXT, and
	      returns the length of it.
	 <li> The user code allocates a memory M to store the text, and
	      calls "copyText(C, M)". This extension copies the
	      content of C into M, then deallocates C.
       </ol>

       Yes, it's pretty hairy and I'm not sure if it's worth implementing.

  <li> Supporting exceptions.

       It's probably easy to support exceptions without arguments.
       For exceptions with arguments, we have the same problem as above.

  <li> Supporting objects.

       It's conceptually easy. Question is who uses them.
       
  <li> Supporting long arguments.

       It's equally easy at least in the conceptual level, but
       the problem is that I don't know the parameter passing
       mechanism of Alpha.

  <li> Supporting non-externalized partially revealed opaques.

       I don't think this is worth implementing. For I don't understand
       the situation such types are used. 

</ul>  

<hr>

<Address>
<A href="http://www.cs.washington.edu/homes/yasushi">
yasushi@cs.washington.edu</a> </address>
</BODY>
</HTML>

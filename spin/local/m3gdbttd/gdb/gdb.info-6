This is Info file ./gdb.info, produced by Makeinfo-1.52 from the input
file gdb.texinfo.

START-INFO-DIR-ENTRY
* Gdb: (gdb).                     The GNU debugger.
END-INFO-DIR-ENTRY
   This file documents the GNU debugger GDB.

   This is Edition 4.12, January 1994, of `Debugging with GDB: the GNU
Source-Level Debugger' for GDB Version 4.13.

   Copyright (C) 1988, '89, '90, '91, '92, '93 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: gdb.info,  Node: Bootstrapping,  Next: Debug Session,  Prev: Stub Contents,  Up: Remote Serial

What you must do for the stub
-----------------------------

   The debugging stubs that come with GDB are set up for a particular
chip architecture, but they have no information about the rest of your
debugging target machine.

   First of all you need to tell the stub how to communicate with the
serial port.

`int getDebugChar()'
     Write this subroutine to read a single character from the serial
     port.  It may be identical to `getchar' for your target system; a
     different name is used to allow you to distinguish the two if you
     wish.

`void putDebugChar(int)'
     Write this subroutine to write a single character to the serial
     port.  It may be identical to `putchar' for your target system; a
     different name is used to allow you to distinguish the two if you
     wish.

   If you want GDB to be able to stop your program while it is running,
you need to use an interrupt-driven serial driver, and arrange for it
to stop when it receives a `^C' (`\003', the control-C character).
That is the character which GDB uses to tell the remote system to stop.

   Getting the debugging target to return the proper status to GDB
probably requires changes to the standard stub; one quick and dirty way
is to just execute a breakpoint instruction (the "dirty" part is that
GDB reports a `SIGTRAP' instead of a `SIGINT').

   Other routines you need to supply are:

`void exceptionHandler (int EXCEPTION_NUMBER, void *EXCEPTION_ADDRESS)'
     Write this function to install EXCEPTION_ADDRESS in the exception
     handling tables.  You need to do this because the stub does not
     have any way of knowing what the exception handling tables on your
     target system are like (for example, the processor's table might
     be in ROM, containing entries which point to a table in RAM).
     eXCEPTION_NUMBER is the exception number which should be changed;
     its meaning is architecture-dependent (for example, different
     numbers might represent divide by zero, misaligned access, etc).
     When this exception occurs, control should be transferred directly
     to EXCEPTION_ADDRESS, and the processor state (stack, registers,
     and so on) should be just as it is when a processor exception
     occurs.  So if you want to use a jump instruction to reach
     EXCEPTION_ADDRESS, it should be a simple jump, not a jump to
     subroutine.

     For the 386, EXCEPTION_ADDRESS should be installed as an interrupt
     gate so that interrupts are masked while the handler runs.  The
     gate should be at privilege level 0 (the most privileged level).
     The SPARC and 68k stubs are able to mask interrupts themself
     without help from `exceptionHandler'.

`void flush_i_cache()'
     Write this subroutine to flush the instruction cache, if any, on
     your target machine.  If there is no instruction cache, this
     subroutine may be a no-op.

     On target machines that have instruction caches, GDB requires this
     function to make certain that the state of your program is stable.

You must also make sure this library routine is available:

`void *memset(void *, int, int)'
     This is the standard library function `memset' that sets an area of
     memory to a known value.  If you have one of the free versions of
     `libc.a', `memset' can be found there; otherwise, you must either
     obtain it from your hardware manufacturer, or write your own.

   If you do not use the GNU C compiler, you may need other standard
library subroutines as well; this varies from one stub to another, but
in general the stubs are likely to use any of the common library
subroutines which `gcc' generates as inline code.


File: gdb.info,  Node: Debug Session,  Next: Protocol,  Prev: Bootstrapping,  Up: Remote Serial

Putting it all together
-----------------------

   In summary, when your program is ready to debug, you must follow
these steps.

  1. Make sure you have the supporting low-level routines (*note What
     you must do for the stub: Bootstrapping.):
          `getDebugChar', `putDebugChar',
          `flush_i_cache', `memset', `exceptionHandler'.

  2. Insert these lines near the top of your program:

          set_debug_traps();
          breakpoint();

  3. For the 680x0 stub only, you need to provide a variable called
     `exceptionHook'.  Normally you just use

          void (*exceptionHook)() = 0;

     but if before calling `set_debug_traps', you set it to point to a
     function in your program, that function is called when `GDB'
     continues after stopping on a trap (for example, bus error).  The
     function indicated by `exceptionHook' is called with one
     parameter: an `int' which is the exception number.

  4. Compile and link together: your program, the GDB debugging stub for
     your target architecture, and the supporting subroutines.

  5. Make sure you have a serial connection between your target machine
     and the GDB host, and identify the serial port used for this on
     the host.

  6. Download your program to your target machine (or get it there by
     whatever means the manufacturer provides), and start it.

  7. To start remote debugging, run GDB on the host machine, and specify
     as an executable file the program that is running in the remote
     machine.  This tells GDB how to find your program's symbols and
     the contents of its pure text.

     Then establish communication using the `target remote' command.
     Its argument specifies how to communicate with the target
     machine--either via a devicename attached to a direct serial line,
     or a TCP port (usually to a terminal server which in turn has a
     serial line to the target).  For example, to use a serial line
     connected to the device named `/dev/ttyb':

          target remote /dev/ttyb

     To use a TCP connection, use an argument of the form `HOST:port'.
     For example, to connect to port 2828 on a terminal server named
     `manyfarms':

          target remote manyfarms:2828

   Now you can use all the usual commands to examine and change data
and to step and continue the remote program.

   To resume the remote program and stop debugging it, use the `detach'
command.

   Whenever GDB is waiting for the remote program, if you type the
interrupt character (often C-C), GDB attempts to stop the program.
This may or may not succeed, depending in part on the hardware and the
serial drivers the remote system uses.  If you type the interrupt
character once again, GDB displays this prompt:

     Interrupted while waiting for the program.
     Give up (and stop debugging it)?  (y or n)

   If you type `y', GDB abandons the remote debugging session.  (If you
decide you want to try again later, you can use `target remote' again
to connect once more.)  If you type `n', GDB goes back to waiting.


File: gdb.info,  Node: Protocol,  Next: Server,  Prev: Debug Session,  Up: Remote Serial

Communication protocol
----------------------

   The stub files provided with GDB implement the target side of the
communication protocol, and the GDB side is implemented in the GDB
source file `remote.c'.  Normally, you can simply allow these
subroutines to communicate, and ignore the details.  (If you're
implementing your own stub file, you can still ignore the details: start
with one of the existing stub files.  `sparc-stub.c' is the best
organized, and therefore the easiest to read.)

   However, there may be occasions when you need to know something about
the protocol--for example, if there is only one serial port to your
target machine, you might want your program to do something special if
it recognizes a packet meant for GDB.

   All GDB commands and responses (other than acknowledgements, which
are single characters) are sent as a packet which includes a checksum.
A packet is introduced with the character `$', and ends with the
character `#' followed by a two-digit checksum:

     $PACKET INFO#CHECKSUM

CHECKSUM is computed as the modulo 256 sum of the PACKET INFO
characters.

   When either the host or the target machine receives a packet, the
first response expected is an acknowledgement: a single character,
either `+' (to indicate the package was received correctly) or `-' (to
request retransmission).

   The host (GDB) sends commands, and the target (the debugging stub
incorporated in your program) sends data in response.  The target also
sends data when your program stops.

   Command packets are distinguished by their first character, which
identifies the kind of command.

   These are the commands currently supported:

`g'
     Requests the values of CPU registers.

`G'
     Sets the values of CPU registers.

`mADDR,COUNT'
     Read COUNT bytes at location ADDR.

`MADDR,COUNT:...'
     Write COUNT bytes at location ADDR.

`c'
`cADDR'
     Resume execution at the current address (or at ADDR if supplied).

`s'
`sADDR'
     Step the target program for one instruction, from either the
     current program counter or from ADDR if supplied.

`k'
     Kill the target program.

`?'
     Report the most recent signal.  To allow you to take advantage of
     the GDB signal handling commands, one of the functions of the
     debugging stub is to report CPU traps as the corresponding POSIX
     signal values.

   If you have trouble with the serial connection, you can use the
command `set remotedebug'.  This makes GDB report on all packets sent
back and forth across the serial line to the remote machine.  The
packet-debugging information is printed on the GDB standard output
stream.  `set remotedebug off' turns it off, and `show remotedebug'
shows you its current state.


File: gdb.info,  Node: Server,  Prev: Protocol,  Up: Remote Serial

Using the `gdbserver' program
-----------------------------

   `gdbserver' is a control program for Unix-like systems, which allows
you to connect your program with a remote GDB via `target remote'--but
without linking in the usual debugging stub.

   `gdbserver' is not a complete replacement for the debugging stubs,
because it requires essentially the same operating-system facilities
that GDB itself does.  In fact, a system that can run `gdbserver' to
connect to a remote GDB could also run GDB locally!  `gdbserver' is
sometimes useful nevertheless, because it is a much smaller program
than GDB itself.  It is also easier to port than all of GDB, so you may
be able to get started more quickly on a new system by using
`gdbserver'.  Finally, if you develop code for real-time systems, you
may find that the tradeoffs involved in real-time operation make it
more convenient to do as much development work as possible on another
system, for example by cross-compiling.  You can use `gdbserver' to
make a similar choice for debugging.

   GDB and `gdbserver' communicate via either a serial line or a TCP
connection, using the standard GDB remote serial protocol.

*On the target machine,*
     you need to have a copy of the program you want to debug.
     `gdbserver' does not need your program's symbol table, so you can
     strip the program if necessary to save space.  GDB on the host
     system does all the symbol handling.

     To use the server, you must tell it how to communicate with GDB;
     the name of your program; and the arguments for your program.  The
     syntax is:

          target> gdbserver COMM PROGRAM [ ARGS ... ]

     COMM is either a device name (to use a serial line) or a TCP
     hostname and portnumber.  For example, to debug Emacs with the
     argument `foo.txt' and communicate with GDB over the serial port
     `/dev/com1':

          target> gdbserver /dev/com1 emacs foo.txt

     `gdbserver' waits passively for the host GDB to communicate with
     it.

     To use a TCP connection instead of a serial line:

          target> gdbserver host:2345 emacs foo.txt

     The only difference from the previous example is the first
     argument, specifying that you are communicating with the host GDB
     via TCP.  The `host:2345' argument means that `gdbserver' is to
     expect a TCP connection from machine `host' to local TCP port 2345.
     (Currently, the `host' part is ignored.)  You can choose any number
     you want for the port number as long as it does not conflict with
     any TCP ports already in use on the target system (for example,
     `23' is reserved for `telnet').(1) You must use the same port
     number with the host GDB `target remote' command.

*On the GDB host machine,*
     you need an unstripped copy of your program, since GDB needs
     symbols and debugging information.  Start up GDB as usual, using
     the name of the local copy of your program as the first argument.
     (You may also need the `--baud' option if the serial line is
     running at anything other than 9600 bps.)  After that, use `target
     remote' to establish communications with `gdbserver'.  Its argument
     is either a device name (usually a serial device, like
     `/dev/ttyb'), or a TCP port descriptor in the form `HOST:PORT'.
     For example:

          (gdb) target remote /dev/ttyb

     communicates with the server via serial line `/dev/ttyb', and

          (gdb) target remote the-target:2345

     communicates via a TCP connection to port 2345 on host
     `the-target'.  For TCP connections, you must start up `gdbserver'
     prior to using the `target remote' command.  Otherwise you may get
     an error whose text depends on the host system, but which usually
     looks something like `Connection refused'.

   ---------- Footnotes ----------

   (1)  If you choose a port number that conflicts with another
service, `gdbserver' prints an error message and exits.


File: gdb.info,  Node: i960-Nindy Remote,  Next: UDI29K Remote,  Prev: Remote Serial,  Up: Remote

GDB with a remote i960 (Nindy)
------------------------------

   "Nindy" is a ROM Monitor program for Intel 960 target systems.  When
GDB is configured to control a remote Intel 960 using Nindy, you can
tell GDB how to connect to the 960 in several ways:

   * Through command line options specifying serial port, version of the
     Nindy protocol, and communications speed;

   * By responding to a prompt on startup;

   * By using the `target' command at any point during your GDB
     session.  *Note Commands for managing targets: Target Commands.

* Menu:

* Nindy Startup::               Startup with Nindy
* Nindy Options::               Options for Nindy
* Nindy Reset::                 Nindy reset command


File: gdb.info,  Node: Nindy Startup,  Next: Nindy Options,  Up: i960-Nindy Remote

Startup with Nindy
------------------

   If you simply start `gdb' without using any command-line options,
you are prompted for what serial port to use, *before* you reach the
ordinary GDB prompt:

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:

Respond to the prompt with whatever suffix (after `/dev/tty')
identifies the serial port you want to use.  You can, if you choose,
simply start up with no Nindy connection by responding to the prompt
with an empty line.  If you do this and later wish to attach to Nindy,
use `target' (*note Commands for managing targets: Target Commands.).


File: gdb.info,  Node: Nindy Options,  Next: Nindy Reset,  Prev: Nindy Startup,  Up: i960-Nindy Remote

Options for Nindy
-----------------

   These are the startup options for beginning your GDB session with a
Nindy-960 board attached:

`-r PORT'
     Specify the serial port name of a serial interface to be used to
     connect to the target system.  This option is only available when
     GDB is configured for the Intel 960 target architecture.  You may
     specify PORT as any of: a full pathname (e.g. `-r /dev/ttya'), a
     device name in `/dev' (e.g. `-r ttya'), or simply the unique
     suffix for a specific `tty' (e.g. `-r a').

`-O'
     (An uppercase letter "O", not a zero.)  Specify that GDB should use
     the "old" Nindy monitor protocol to connect to the target system.
     This option is only available when GDB is configured for the Intel
     960 target architecture.

          *Warning:* if you specify `-O', but are actually trying to
          connect to a target system that expects the newer protocol,
          the connection fails, appearing to be a speed mismatch.  GDB
          repeatedly attempts to reconnect at several different line
          speeds.  You can abort this process with an interrupt.

`-brk'
     Specify that GDB should first send a `BREAK' signal to the target
     system, in an attempt to reset it, before connecting to a Nindy
     target.

          *Warning:* Many target systems do not have the hardware that
          this requires; it only works with a few boards.

   The standard `-b' option controls the line speed used on the serial
port.


File: gdb.info,  Node: Nindy Reset,  Prev: Nindy Options,  Up: i960-Nindy Remote

Nindy reset command
-------------------

`reset'
     For a Nindy target, this command sends a "break" to the remote
     target system; this is only useful if the target has been equipped
     with a circuit to perform a hard reset (or some other interesting
     action) when a break is detected.


File: gdb.info,  Node: UDI29K Remote,  Next: EB29K Remote,  Prev: i960-Nindy Remote,  Up: Remote

The UDI protocol for AMD29K
---------------------------

   GDB supports AMD's UDI ("Universal Debugger Interface") protocol for
debugging the a29k processor family.  To use this configuration with
AMD targets running the MiniMON monitor, you need the program `MONTIP',
available from AMD at no charge.  You can also use GDB with the UDI
conformant a29k simulator program `ISSTIP', also available from AMD.

`target udi KEYWORD'
     Select the UDI interface to a remote a29k board or simulator, where
     KEYWORD is an entry in the AMD configuration file `udi_soc'.  This
     file contains keyword entries which specify parameters used to
     connect to a29k targets.  If the `udi_soc' file is not in your
     working directory, you must set the environment variable `UDICONF'
     to its pathname.


File: gdb.info,  Node: EB29K Remote,  Next: VxWorks Remote,  Prev: UDI29K Remote,  Up: Remote

The EBMON protocol for AMD29K
-----------------------------

   AMD distributes a 29K development board meant to fit in a PC,
together with a DOS-hosted monitor program called `EBMON'.  As a
shorthand term, this development system is called the "EB29K".  To use
GDB from a Unix system to run programs on the EB29K board, you must
first connect a serial cable between the PC (which hosts the EB29K
board) and a serial port on the Unix system.  In the following, we
assume you've hooked the cable between the PC's `COM1' port and
`/dev/ttya' on the Unix system.

* Menu:

* Comms (EB29K)::               Communications setup
* gdb-EB29K::                   EB29K cross-debugging
* Remote Log::                  Remote log


File: gdb.info,  Node: Comms (EB29K),  Next: gdb-EB29K,  Up: EB29K Remote

Communications setup
--------------------

   The next step is to set up the PC's port, by doing something like
this in DOS on the PC:

     C:\> MODE com1:9600,n,8,1,none

This example--run on an MS DOS 4.0 system--sets the PC port to 9600
bps, no parity, eight data bits, one stop bit, and no "retry" action;
you must match the communications parameters when establishing the Unix
end of the connection as well.

   To give control of the PC to the Unix side of the serial line, type
the following at the DOS console:

     C:\> CTTY com1

(Later, if you wish to return control to the DOS console, you can use
the command `CTTY con'--but you must send it over the device that had
control, in our example over the `COM1' serial line).

   From the Unix host, use a communications program such as `tip' or
`cu' to communicate with the PC; for example,

     cu -s 9600 -l /dev/ttya

The `cu' options shown specify, respectively, the linespeed and the
serial port to use.  If you use `tip' instead, your command line may
look something like the following:

     tip -9600 /dev/ttya

Your system may require a different name where we show `/dev/ttya' as
the argument to `tip'.  The communications parameters, including which
port to use, are associated with the `tip' argument in the "remote"
descriptions file--normally the system table `/etc/remote'.

   Using the `tip' or `cu' connection, change the DOS working directory
to the directory containing a copy of your 29K program, then start the
PC program `EBMON' (an EB29K control program supplied with your board
by AMD).  You should see an initial display from `EBMON' similar to the
one that follows, ending with the `EBMON' prompt `#'--

     C:\> G:
     
     G:\> CD \usr\joe\work29k
     
     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.
     
     Enter '?' or 'H' for help
     
     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000
     
     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff
     
     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800
     
     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes
     
     # ~.

   Then exit the `cu' or `tip' program (done in the example by typing
`~.' at the `EBMON' prompt).  `EBMON' keeps running, ready for GDB to
take over.

   For this example, we've assumed what is probably the most convenient
way to make sure the same 29K program is on both the PC and the Unix
system: a PC/NFS connection that establishes "drive `G:'" on the PC as
a file system on the Unix host.  If you do not have PC/NFS or something
similar connecting the two systems, you must arrange some other
way--perhaps floppy-disk transfer--of getting the 29K program from the
Unix system to the PC; GDB does *not* download it over the serial line.


File: gdb.info,  Node: gdb-EB29K,  Next: Remote Log,  Prev: Comms (EB29K),  Up: EB29K Remote

EB29K cross-debugging
---------------------

   Finally, `cd' to the directory containing an image of your 29K
program on the Unix system, and start GDB--specifying as argument the
name of your 29K program:

     cd /usr/joe/work29k
     gdb myfoo

   Now you can use the `target' command:

     target amd-eb /dev/ttya 9600 MYFOO

In this example, we've assumed your program is in a file called
`myfoo'.  Note that the filename given as the last argument to `target
amd-eb' should be the name of the program as it appears to DOS.  In our
example this is simply `MYFOO', but in general it can include a DOS
path, and depending on your transfer mechanism may not resemble the
name on the Unix side.

   At this point, you can set any breakpoints you wish; when you are
ready to see your program run on the 29K board, use the GDB command
`run'.

   To stop debugging the remote program, use the GDB `detach' command.

   To return control of the PC to its console, use `tip' or `cu' once
again, after your GDB session has concluded, to attach to `EBMON'.  You
can then type the command `q' to shut down `EBMON', returning control
to the DOS command-line interpreter.  Type `CTTY con' to return command
input to the main DOS console, and type `~.' to leave `tip' or `cu'.


File: gdb.info,  Node: Remote Log,  Prev: gdb-EB29K,  Up: EB29K Remote

Remote log
----------

   The `target amd-eb' command creates a file `eb.log' in the current
working directory, to help debug problems with the connection.
`eb.log' records all the output from `EBMON', including echoes of the
commands sent to it.  Running `tail -f' on this file in another window
often helps to understand trouble with `EBMON', or unexpected events on
the PC side of the connection.


File: gdb.info,  Node: ST2000 Remote,  Next: Hitachi Remote,  Prev: VxWorks Remote,  Up: Remote

GDB with a Tandem ST2000
------------------------

   To connect your ST2000 to the host system, see the manufacturer's
manual.  Once the ST2000 is physically attached, you can run

     target st2000 DEV SPEED

to establish it as your debugging environment.  DEV is normally the
name of a serial device, such as `/dev/ttya', connected to the ST2000
via a serial line.  You can instead specify DEV as a TCP connection
(for example, to a serial line attached via a terminal concentrator)
using the syntax `HOSTNAME:PORTNUMBER'.

   The `load' and `attach' commands are *not* defined for this target;
you must load your program into the ST2000 as you normally would for
standalone operation.  GDB reads debugging information (such as
symbols) from a separate, debugging version of the program available on
your host computer.

   These auxiliary GDB commands are available to help you with the
ST2000 environment:

`st2000 COMMAND'
     Send a COMMAND to the STDBUG monitor.  See the manufacturer's
     manual for available commands.

`connect'
     Connect the controlling terminal to the STDBUG command monitor.
     When you are done interacting with STDBUG, typing either of two
     character sequences gets you back to the GDB command prompt:
     `RET~.' (Return, followed by tilde and period) or `RET~C-d'
     (Return, followed by tilde and control-D).


File: gdb.info,  Node: VxWorks Remote,  Next: ST2000 Remote,  Prev: EB29K Remote,  Up: Remote

GDB and VxWorks
---------------

   GDB enables developers to spawn and debug tasks running on networked
VxWorks targets from a Unix host.  Already-running tasks spawned from
the VxWorks shell can also be debugged.  GDB uses code that runs on
both the Unix host and on the VxWorks target.  The program `gdb' is
installed and executed on the Unix host.  (It may be installed with the
name `vxgdb', to distinguish it from a GDB for debugging programs on
the host itself.)

   The following information on connecting to VxWorks was current when
this manual was produced; newer releases of VxWorks may use revised
procedures.

   To use GDB with VxWorks, you must rebuild your VxWorks kernel to
include the remote debugging interface routines in the VxWorks library
`rdb.a'.  To do this, define `INCLUDE_RDB' in the VxWorks configuration
file `configAll.h' and rebuild your VxWorks kernel.  The resulting
kernel contains `rdb.a', and spawns the source debugging task
`tRdbTask' when VxWorks is booted.  For more information on configuring
and remaking VxWorks, see the manufacturer's manual.

   Once you have included `rdb.a' in your VxWorks system image and set
your Unix execution search path to find GDB, you are ready to run GDB.
From your Unix host, run `gdb' (or `vxgdb', depending on your
installation).

   GDB comes up showing the prompt:

     (vxgdb)

* Menu:

* VxWorks Connection::          Connecting to VxWorks
* VxWorks Download::            VxWorks download
* VxWorks Attach::              Running tasks


File: gdb.info,  Node: VxWorks Connection,  Next: VxWorks Download,  Up: VxWorks Remote

Connecting to VxWorks
---------------------

   The GDB command `target' lets you connect to a VxWorks target on the
network.  To connect to a target whose host name is "`tt'", type:

     (vxgdb) target vxworks tt

   GDB displays messages like these:

     Attaching remote machine across net...
     Connected to tt.

   GDB then attempts to read the symbol tables of any object modules
loaded into the VxWorks target since it was last booted.  GDB locates
these files by searching the directories listed in the command search
path (*note Your program's environment: Environment.); if it fails to
find an object file, it displays a message such as:

     prog.o: No such file or directory.

   When this happens, add the appropriate directory to the search path
with the GDB command `path', and execute the `target' command again.


File: gdb.info,  Node: VxWorks Download,  Next: VxWorks Attach,  Prev: VxWorks Connection,  Up: VxWorks Remote

VxWorks download
----------------

   If you have connected to the VxWorks target and you want to debug an
object that has not yet been loaded, you can use the GDB `load' command
to download a file from Unix to VxWorks incrementally.  The object file
given as an argument to the `load' command is actually opened twice:
first by the VxWorks target in order to download the code, then by GDB
in order to read the symbol table.  This can lead to problems if the
current working directories on the two systems differ.  If both systems
have NFS mounted the same filesystems, you can avoid these problems by
using absolute paths.  Otherwise, it is simplest to set the working
directory on both systems to the directory in which the object file
resides, and then to reference the file by its name, without any path.
For instance, a program `prog.o' may reside in `VXPATH/vw/demo/rdb' in
VxWorks and in `HOSTPATH/vw/demo/rdb' on the host.  To load this
program, type this on VxWorks:

     -> cd "VXPATH/vw/demo/rdb"

   Then, in GDB, type:

     (vxgdb) cd HOSTPATH/vw/demo/rdb
     (vxgdb) load prog.o

   GDB displays a response similar to this:

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

   You can also use the `load' command to reload an object module after
editing and recompiling the corresponding source file.  Note that this
makes GDB delete all currently-defined breakpoints, auto-displays, and
convenience variables, and to clear the value history.  (This is
necessary in order to preserve the integrity of debugger data
structures that reference the target system's symbol table.)


File: gdb.info,  Node: VxWorks Attach,  Prev: VxWorks Download,  Up: VxWorks Remote

Running tasks
-------------

   You can also attach to an existing task using the `attach' command as
follows:

     (vxgdb) attach TASK

where TASK is the VxWorks hexadecimal task ID.  The task can be running
or suspended when you attach to it.  Running tasks are suspended at the
time of attachment.


File: gdb.info,  Node: Hitachi Remote,  Next: MIPS Remote,  Prev: ST2000 Remote,  Up: Remote

GDB and Hitachi microprocessors
-------------------------------

   GDB needs to know these things to talk to your Hitachi SH, H8/300,
or H8/500:

  1. that you want to use `target hms', the remote debugging interface
     for Hitachi microprocessors, or `target e7000', the in-circuit
     emulator for the Hitachi SH and the Hitachi 300H.  (`target hms' is
     the default when GDB is configured specifically for the Hitachi SH,
     H8/300, or H8/500.)

  2. what serial device connects your host to your Hitachi board (the
     first serial device available on your host is the default).

  3. what speed to use over the serial device.

* Menu:

* Hitachi Boards::      Connecting to Hitachi boards.
* Hitachi ICE::         Using the E7000 In-Circuit Emulator.
* Hitachi Special::     Special GDB commands for Hitachi micros.


File: gdb.info,  Node: Hitachi Boards,  Next: Hitachi ICE,  Up: Hitachi Remote

Connecting to Hitachi boards
----------------------------

   Use the special `gdb' command `device PORT' if you need to
explicitly set the serial device.  The default PORT is the first
available port on your host.  This is only necessary on Unix hosts,
where it is typically something like `/dev/ttya'.

   `gdb' has another special command to set the communications speed:
`speed BPS'.  This command also is only used from Unix hosts; on DOS
hosts, set the line speed as usual from outside GDB with the DOS `mode'
command (for instance, `mode com2:9600,n,8,1,p' for a 9600 bps
connection).

   The `device' and `speed' commands are available only when you use a
Unix host to debug your Hitachi microprocessor programs.  If you use a
DOS host, GDB depends on an auxiliary terminate-and-stay-resident
program called `asynctsr' to communicate with the development board
through a PC serial port.  You must also use the DOS `mode' command to
set up the serial port on the DOS side.


File: gdb.info,  Node: Hitachi ICE,  Next: Hitachi Special,  Prev: Hitachi Boards,  Up: Hitachi Remote

Using the E7000 in-circuit emulator
-----------------------------------

   You can use the E7000 in-circuit emulator to develop code for either
the Hitachi SH or the H8/300H.  Use one of these forms of the `target
e7000' command to connect GDB to your E7000:

`target e7000 PORT SPEED'
     Use this form if your E7000 is connected to a serial port.  The
     PORT argument identifies what serial port to use (for example,
     `com2').  The third argument is the line speed in bits per second
     (for example, `9600').

`target e7000 HOSTNAME'
     If your E7000 is installed as a host on a TCP/IP network, you can
     just specify its hostname; GDB uses `telnet' to connect.


File: gdb.info,  Node: Hitachi Special,  Prev: Hitachi ICE,  Up: Hitachi Remote

Special GDB commands for Hitachi micros
---------------------------------------

   Some GDB commands are available only on the H8/300 or the H8/500
configurations:

`set machine h8300'
`set machine h8300h'
     Condition GDB for one of the two variants of the H8/300
     architecture with `set machine'.  You can use `show machine' to
     check which variant is currently in effect.

`set memory MOD'
`show memory'
     Specify which H8/500 memory model (MOD) you are using with `set
     memory'; check which memory model is in effect with `show memory'.
     The accepted values for MOD are `small', `big', `medium', and
     `compact'.


File: gdb.info,  Node: MIPS Remote,  Next: Simulator,  Prev: Hitachi Remote,  Up: Remote

GDB and remote MIPS boards
--------------------------

   GDB can use the MIPS remote debugging protocol to talk to a MIPS
board attached to a serial line.  This is available when you configure
GDB with `--target=mips-idt-ecoff'.

   Use these GDB commands to specify the connection to your target
board:

`target mips PORT'
     To run a program on the board, start up `gdb' with the name of
     your program as the argument.  To connect to the board, use the
     command `target mips PORT', where PORT is the name of the serial
     port connected to the board.  If the program has not already been
     downloaded to the board, you may use the `load' command to
     download it.  You can then use all the usual GDB commands.

     For example, this sequence connects to the target board through a
     serial port, and loads and runs a program called PROG through the
     debugger:

          host$ gdb PROG
          GDB is free software and ...
          (gdb) target mips /dev/ttyb
          (gdb) load PROG
          (gdb) run

`target mips HOSTNAME:PORTNUMBER'
     On some GDB host configurations, you can specify a TCP connection
     (for instance, to a serial line managed by a terminal
     concentrator) instead of a serial port, using the syntax
     `HOSTNAME:PORTNUMBER'.

GDB also supports these special commands for MIPS targets:

`set mipsfpu off'
`show mipsfpu'
     If your target board does not support the MIPS floating point
     coprocessor, you should use the command `set mipsfpu off' (if you
     need this, you may wish to put the command in your .gdbinit file).
     This tells GDB how to find the return value of functions which
     return floating point values.  It also allows GDB to avoid saving
     the floating point registers when calling functions on the board.
     (As usual, you can inquire about the `mipsfpu' variable with `show
     mipsfpu'.)

`set remotedebug N'
`show remotedebug'
     You can see some debugging information about communications with
     the board by setting the `remotedebug' variable.  If you set it to
     `1' using `set remotedebug 1', every packet is displayed.  If you
     set it to `2', every character is displayed.  You can check the
     current value at any time with the command `show remotedebug'.

`set timeout SECONDS'
`set retransmit-timeout SECONDS'
`show timeout'
`show retransmit-timeout'
     You can control the timeout used while waiting for a packet, in
     the MIPS remote protocol, with the `set timeout SECONDS' command.
     The default is 5 seconds.  Similarly, you can control the timeout
     used while waiting for an acknowledgement of a packet with the `set
     retransmit-timeout SECONDS' command.  The default is 3 seconds.
     You can inspect both values with `show timeout' and `show
     retransmit-timeout'.  (These commands are *only* available when
     GDB is configured for `--target=mips-idt-ecoff'.)

     The timeout set by `set timeout' does not apply when GDB is
     waiting for your program to stop.  In that case, GDB waits forever
     because it has no way of knowing how long the program is going to
     run before stopping.


File: gdb.info,  Node: Simulator,  Prev: MIPS Remote,  Up: Remote

Simulated CPU target
--------------------

   For some configurations, GDB includes a CPU simulator that you can
use instead of a hardware CPU to debug your programs.  Currently, a
simulator is available when GDB is configured to debug Zilog Z8000 or
Hitachi microprocessor targets.

   For the Z8000 family, `target sim' simulates either the Z8002 (the
unsegmented variant of the Z8000 architecture) or the Z8001 (the
segmented variant).  The simulator recognizes which architecture is
appropriate by inspecting the object code.

`target sim'
     Debug programs on a simulated CPU (which CPU depends on the GDB
     configuration)

After specifying this target, you can debug programs for the simulated
CPU in the same style as programs for your host computer; use the
`file' command to load a new program image, the `run' command to run
your program, and so on.

   As well as making available all the usual machine registers (see
`info reg'), this debugging target provides three additional items of
information as specially named registers:

`cycles'
     Counts clock-ticks in the simulator.

`insts'
     Counts instructions run in the simulator.

`time'
     Execution time in 60ths of a second.

   You can refer to these values in GDB expressions with the usual
conventions; for example, `b fputc if $cycles>5000' sets a conditional
breakpoint that suspends only after at least 5000 simulated clock ticks.


File: gdb.info,  Node: Controlling GDB,  Next: Sequences,  Prev: Targets,  Up: Top

Controlling GDB
***************

   You can alter the way GDB interacts with you by using the `set'
command.  For commands controlling how GDB displays data, *note Print
settings: Print Settings.; other settings are described here.

* Menu:

* Prompt::                      Prompt
* Editing::                     Command editing
* History::                     Command history
* Screen Size::                 Screen size
* Numbers::                     Numbers
* Messages/Warnings::           Optional warnings and messages


File: gdb.info,  Node: Prompt,  Next: Editing,  Up: Controlling GDB

Prompt
======

   GDB indicates its readiness to read a command by printing a string
called the "prompt".  This string is normally `(gdb)'.  You can change
the prompt string with the `set prompt' command.  For instance, when
debugging GDB with GDB, it is useful to change the prompt in one of the
GDB sessions so that you can always tell which one you are talking to.

`set prompt NEWPROMPT'
     Directs GDB to use NEWPROMPT as its prompt string henceforth.

`show prompt'
     Prints a line of the form: `Gdb's prompt is: YOUR-PROMPT'


File: gdb.info,  Node: Editing,  Next: History,  Prev: Prompt,  Up: Controlling GDB

Command editing
===============

   GDB reads its input commands via the "readline" interface.  This GNU
library provides consistent behavior for programs which provide a
command line interface to the user.  Advantages are `emacs'-style or
`vi'-style inline editing of commands, `csh'-like history substitution,
and a storage and recall of command history across debugging sessions.

   You may control the behavior of command line editing in GDB with the
command `set'.

`set editing'
`set editing on'
     Enable command line editing (enabled by default).

`set editing off'
     Disable command line editing.

`show editing'
     Show whether command line editing is enabled.


File: gdb.info,  Node: History,  Next: Screen Size,  Prev: Editing,  Up: Controlling GDB

Command history
===============

   GDB can keep track of the commands you type during your debugging
sessions, so that you can be certain of precisely what happened.  Use
these commands to manage the GDB command history facility.

`set history filename FNAME'
     Set the name of the GDB command history file to FNAME.  This is
     the file where GDB reads an initial command history list, and
     where it writes the command history from this session when it
     exits.  You can access this list through history expansion or
     through the history command editing characters listed below.  This
     file defaults to the value of the environment variable
     `GDBHISTFILE', or to `./.gdb_history' if this variable is not set.

`set history save'
`set history save on'
     Record command history in a file, whose name may be specified with
     the `set history filename' command.  By default, this option is
     disabled.

`set history save off'
     Stop recording command history in a file.

`set history size SIZE'
     Set the number of commands which GDB keeps in its history list.
     This defaults to the value of the environment variable `HISTSIZE',
     or to 256 if this variable is not set.

   History expansion assigns special meaning to the character `!'.

   Since `!' is also the logical not operator in C, history expansion
is off by default. If you decide to enable history expansion with the
`set history expansion on' command, you may sometimes need to follow
`!' (when it is used as logical not, in an expression) with a space or
a tab to prevent it from being expanded.  The readline history
facilities do not attempt substitution on the strings `!=' and `!(',
even when history expansion is enabled.

   The commands to control history expansion are:

`set history expansion on'
`set history expansion'
     Enable history expansion.  History expansion is off by default.

`set history expansion off'
     Disable history expansion.

     The readline code comes with more complete documentation of
     editing and history expansion features.  Users unfamiliar with
     `emacs' or `vi' may wish to read it.

`show history'
`show history filename'
`show history save'
`show history size'
`show history expansion'
     These commands display the state of the GDB history parameters.
     `show history' by itself displays all four states.

`show commands'
     Display the last ten commands in the command history.

`show commands N'
     Print ten commands centered on command number N.

`show commands +'
     Print ten commands just after the commands last printed.


File: gdb.info,  Node: Screen Size,  Next: Numbers,  Prev: History,  Up: Controlling GDB

Screen size
===========

   Certain commands to GDB may produce large amounts of information
output to the screen.  To help you read all of it, GDB pauses and asks
you for input at the end of each page of output.  Type RET when you
want to continue the output, or `q' to discard the remaining output.
Also, the screen width setting determines when to wrap lines of output.
Depending on what is being printed, GDB tries to break the line at a
readable place, rather than simply letting it overflow onto the
following line.

   Normally GDB knows the size of the screen from the termcap data base
together with the value of the `TERM' environment variable and the
`stty rows' and `stty cols' settings. If this is not correct, you can
override it with the `set height' and `set width' commands:

`set height LPP'
`show height'
`set width CPL'
`show width'
     These `set' commands specify a screen height of LPP lines and a
     screen width of CPL characters.  The associated `show' commands
     display the current settings.

     If you specify a height of zero lines, GDB does not pause during
     output no matter how long the output is.  This is useful if output
     is to a file or to an editor buffer.

     Likewise, you can specify `set width 0' to prevent GDB from
     wrapping its output.


File: gdb.info,  Node: Numbers,  Next: Messages/Warnings,  Prev: Screen Size,  Up: Controlling GDB

Numbers
=======

   You can always enter numbers in octal, decimal, or hexadecimal in
GDB by the usual conventions: octal numbers begin with `0', decimal
numbers end with `.', and hexadecimal numbers begin with `0x'.  Numbers
that begin with none of these are, by default, entered in base 10;
likewise, the default display for numbers--when no particular format is
specified--is base 10.  You can change the default base for both input
and output with the `set radix' command.

`set radix BASE'
     Set the default base for numeric input and display.  Supported
     choices for BASE are decimal 8, 10, or 16.  BASE must itself be
     specified either unambiguously or using the current default radix;
     for example, any of

          set radix 012
          set radix 10.
          set radix 0xa

     sets the base to decimal.  On the other hand, `set radix 10'
     leaves the radix unchanged no matter what it was.

`show radix'
     Display the current default base for numeric input and display.


File: gdb.info,  Node: Messages/Warnings,  Prev: Numbers,  Up: Controlling GDB

Optional warnings and messages
==============================

   By default, GDB is silent about its inner workings.  If you are
running on a slow machine, you may want to use the `set verbose'
command.  It makes GDB tell you when it does a lengthy internal
operation, so you will not think it has crashed.

   Currently, the messages controlled by `set verbose' are those which
announce that the symbol table for a source file is being read; see
`symbol-file' in *Note Commands to specify files: Files.

`set verbose on'
     Enables GDB output of certain informational messages.

`set verbose off'
     Disables GDB output of certain informational messages.

`show verbose'
     Displays whether `set verbose' is on or off.

   By default, if GDB encounters bugs in the symbol table of an object
file, it is silent; but if you are debugging a compiler, you may find
this information useful (*note Errors reading symbol files: Symbol
Errors.).

`set complaints LIMIT'
     Permits GDB to output LIMIT complaints about each type of unusual
     symbols before becoming silent about the problem.  Set LIMIT to
     zero to suppress all complaints; set it to a large number to
     prevent complaints from being suppressed.

`show complaints'
     Displays how many symbol complaints GDB is permitted to produce.

   By default, GDB is cautious, and asks what sometimes seems to be a
lot of stupid questions to confirm certain commands.  For example, if
you try to run a program which is already running:

     (gdb) run
     The program being debugged has been started already.
     Start it from the beginning? (y or n)

   If you are willing to unflinchingly face the consequences of your own
commands, you can disable this "feature":

`set confirm off'
     Disables confirmation requests.

`set confirm on'
     Enables confirmation requests (the default).

`show confirm'
     Displays state of confirmation requests.

   Some systems allow individual object files that make up your program
to be replaced without stopping and restarting your program.  For
example, in VxWorks you can simply recompile a defective object file
and keep on running.  If you are running on one of these systems, you
can allow GDB to reload the symbols for automatically relinked modules:

`set symbol-reloading on'
     Replace symbol definitions for the corresponding source file when
     an object file with a particular name is seen again.

`set symbol-reloading off'
     Do not replace symbol definitions when re-encountering object
     files of the same name.  This is the default state; if you are not
     running on a system that permits automatically relinking modules,
     you should leave `symbol-reloading' off, since otherwise GDB may
     discard symbols when linking large programs, that may contain
     several modules (from different directories or libraries) with the
     same name.

`show symbol-reloading'
     Show the current `on' or `off' setting.


File: gdb.info,  Node: Sequences,  Next: Emacs,  Prev: Controlling GDB,  Up: Top

Canned Sequences of Commands
****************************

   Aside from breakpoint commands (*note Breakpoint command lists:
Break Commands.), GDB provides two ways to store sequences of commands
for execution as a unit: user-defined commands and command files.

* Menu:

* Define::                      User-defined commands
* Hooks::			User-defined command hooks
* Command Files::               Command files
* Output::                      Commands for controlled output

